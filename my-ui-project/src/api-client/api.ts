/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI Example
 * This is an  OpenAPI specification for Rest Countries API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AllresponsebodyInner
 */
export interface AllresponsebodyInner {
    /**
     * 
     * @type {NameDetails}
     * @memberof AllresponsebodyInner
     */
    'name'?: NameDetails;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllresponsebodyInner
     */
    'tld'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'cca2'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'cca3'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'ccn3'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'cioc'?: string;
    /**
     * 
     * @type {{ [key: string]: CurrenciesDetails; }}
     * @memberof AllresponsebodyInner
     */
    'currencies'?: { [key: string]: CurrenciesDetails; };
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'region'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AllresponsebodyInner
     */
    'independent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AllresponsebodyInner
     */
    'unMember'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllresponsebodyInner
     */
    'capital'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AllresponsebodyInner
     */
    'latlng'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof AllresponsebodyInner
     */
    'area'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllresponsebodyInner
     */
    'population'?: number;
    /**
     * 
     * @type {AllresponsebodyInnerFlags}
     * @memberof AllresponsebodyInner
     */
    'flags'?: AllresponsebodyInnerFlags;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'flag'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AllresponsebodyInner
     */
    'landlocked'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllresponsebodyInner
     */
    'borders'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: NativeNameDetail; }}
     * @memberof AllresponsebodyInner
     */
    'translations'?: { [key: string]: NativeNameDetail; };
    /**
     * 
     * @type {{ [key: string]: DemonymsDetails; }}
     * @memberof AllresponsebodyInner
     */
    'demonyms'?: { [key: string]: DemonymsDetails; };
    /**
     * 
     * @type {Array<string>}
     * @memberof AllresponsebodyInner
     */
    'timezones'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllresponsebodyInner
     */
    'continents'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'fifa'?: string;
    /**
     * 
     * @type {CarDetails}
     * @memberof AllresponsebodyInner
     */
    'car'?: CarDetails;
    /**
     * 
     * @type {ImageDetails}
     * @memberof AllresponsebodyInner
     */
    'coatOfArms'?: ImageDetails;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'startOfWeek'?: string;
    /**
     * 
     * @type {AllresponsebodyInnerCapitalInfo}
     * @memberof AllresponsebodyInner
     */
    'capitalInfo'?: AllresponsebodyInnerCapitalInfo;
    /**
     * 
     * @type {MapsDetails}
     * @memberof AllresponsebodyInner
     */
    'maps'?: MapsDetails;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AllresponsebodyInner
     */
    'gini'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInner
     */
    'subregion'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllresponsebodyInner
     */
    'altSpellings'?: Array<string>;
    /**
     * 
     * @type {IddDetails}
     * @memberof AllresponsebodyInner
     */
    'idd'?: IddDetails;
    /**
     * 
     * @type {PostalCodeDetails}
     * @memberof AllresponsebodyInner
     */
    'postalCode'?: PostalCodeDetails;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AllresponsebodyInner
     */
    'languages'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AllresponsebodyInnerCapitalInfo
 */
export interface AllresponsebodyInnerCapitalInfo {
    /**
     * 
     * @type {Array<number>}
     * @memberof AllresponsebodyInnerCapitalInfo
     */
    'latlng'?: Array<number>;
}
/**
 * 
 * @export
 * @interface AllresponsebodyInnerFlags
 */
export interface AllresponsebodyInnerFlags {
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInnerFlags
     */
    'png': string;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInnerFlags
     */
    'svg': string;
    /**
     * 
     * @type {string}
     * @memberof AllresponsebodyInnerFlags
     */
    'alt': string;
}
/**
 * 
 * @export
 * @interface CarDetails
 */
export interface CarDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof CarDetails
     */
    'signs'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CarDetails
     */
    'side'?: string;
}
/**
 * 
 * @export
 * @interface CurrenciesDetails
 */
export interface CurrenciesDetails {
    /**
     * 
     * @type {string}
     * @memberof CurrenciesDetails
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrenciesDetails
     */
    'symbol'?: string;
}
/**
 * 
 * @export
 * @interface DemonymsDetails
 */
export interface DemonymsDetails {
    /**
     * 
     * @type {string}
     * @memberof DemonymsDetails
     */
    'f'?: string;
    /**
     * 
     * @type {string}
     * @memberof DemonymsDetails
     */
    'm'?: string;
}
/**
 * 
 * @export
 * @interface IddDetails
 */
export interface IddDetails {
    /**
     * 
     * @type {string}
     * @memberof IddDetails
     */
    'root'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IddDetails
     */
    'suffixes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ImageDetails
 */
export interface ImageDetails {
    /**
     * 
     * @type {string}
     * @memberof ImageDetails
     */
    'png': string;
    /**
     * 
     * @type {string}
     * @memberof ImageDetails
     */
    'svg': string;
    /**
     * 
     * @type {string}
     * @memberof ImageDetails
     */
    'alt'?: string;
}
/**
 * 
 * @export
 * @interface MapsDetails
 */
export interface MapsDetails {
    /**
     * 
     * @type {string}
     * @memberof MapsDetails
     */
    'googleMaps'?: string;
    /**
     * 
     * @type {string}
     * @memberof MapsDetails
     */
    'openStreetMaps'?: string;
}
/**
 * 
 * @export
 * @interface NameDetails
 */
export interface NameDetails {
    /**
     * 
     * @type {string}
     * @memberof NameDetails
     */
    'common'?: string;
    /**
     * 
     * @type {string}
     * @memberof NameDetails
     */
    'official'?: string;
    /**
     * 
     * @type {{ [key: string]: NativeNameDetail; }}
     * @memberof NameDetails
     */
    'nativeName'?: { [key: string]: NativeNameDetail; };
}
/**
 * 
 * @export
 * @interface NativeNameDetail
 */
export interface NativeNameDetail {
    /**
     * 
     * @type {string}
     * @memberof NativeNameDetail
     */
    'official'?: string;
    /**
     * 
     * @type {string}
     * @memberof NativeNameDetail
     */
    'common'?: string;
}
/**
 * 
 * @export
 * @interface PostalCodeDetails
 */
export interface PostalCodeDetails {
    /**
     * 
     * @type {string}
     * @memberof PostalCodeDetails
     */
    'format'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostalCodeDetails
     */
    'regex'?: string;
}

/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a simple example response.
         * @summary GET endpoint for retrieving all countries
         * @param {Array<string>} fields Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries: async (fields: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fields' is not null or undefined
            assertParamExists('getAllCountries', 'fields', fields)
            const localVarPath = `/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search by capital city name
         * @param {string} capital The capital city name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByCapital: async (capital: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'capital' is not null or undefined
            assertParamExists('getCountryByCapital', 'capital', capital)
            const localVarPath = `/capital/{capital}`
                .replace(`{${"capital"}}`, encodeURIComponent(String(capital)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search by country code. It can be the 2-letter or 3-letter code
         * @param {string} code The country code to search ,for example for moldova 2-letter code i.e cca2  &#x3D; MD, 3-letter code i.e cca3 and cioc&#x3D; MDA, numeric code  i.e ccn3&#x3D;498
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByCode: async (code: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getCountryByCode', 'code', code)
            const localVarPath = `/alpha/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search by currency code
         * @param {string} currency The currency code to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByCurrency: async (currency: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('getCountryByCurrency', 'currency', currency)
            const localVarPath = `/currency/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search by language code
         * @param {string} language The language code to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByLanguage: async (language: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getCountryByLanguage', 'language', language)
            const localVarPath = `/lang/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search by country name. If you want to get an exact match, use the next endpoint. It can be the common or official value
         * @param {string} name The name of the country to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {boolean} [fullText] Whether to perform a full-text search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByName: async (name: string, fields?: Array<string>, fullText?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCountryByName', 'name', name)
            const localVarPath = `/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (fullText !== undefined) {
                localVarQueryParameter['fullText'] = fullText;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search by region name
         * @param {string} region The region name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByRegion: async (region: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getCountryByRegion', 'region', region)
            const localVarPath = `/region/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search by subregion name
         * @param {string} subregion The subregion name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryBySubregion: async (subregion: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subregion' is not null or undefined
            assertParamExists('getCountryBySubregion', 'subregion', subregion)
            const localVarPath = `/subregion/{subregion}`
                .replace(`{${"subregion"}}`, encodeURIComponent(String(subregion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search by translation name
         * @param {string} translation The translation name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByTranslation: async (translation: string, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'translation' is not null or undefined
            assertParamExists('getCountryByTranslation', 'translation', translation)
            const localVarPath = `/translation/{translation}`
                .replace(`{${"translation"}}`, encodeURIComponent(String(translation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get independent countries
         * @param {boolean} status Status of the countries to filter by
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndependentCountries: async (status: boolean, fields?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getIndependentCountries', 'status', status)
            const localVarPath = `/independent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a simple example response.
         * @summary GET endpoint for retrieving all countries
         * @param {Array<string>} fields Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries(fields: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries(fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getAllCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search by capital city name
         * @param {string} capital The capital city name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByCapital(capital: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByCapital(capital, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByCapital']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search by country code. It can be the 2-letter or 3-letter code
         * @param {string} code The country code to search ,for example for moldova 2-letter code i.e cca2  &#x3D; MD, 3-letter code i.e cca3 and cioc&#x3D; MDA, numeric code  i.e ccn3&#x3D;498
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByCode(code: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByCode(code, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search by currency code
         * @param {string} currency The currency code to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByCurrency(currency: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByCurrency(currency, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByCurrency']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search by language code
         * @param {string} language The language code to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByLanguage(language: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByLanguage(language, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search by country name. If you want to get an exact match, use the next endpoint. It can be the common or official value
         * @param {string} name The name of the country to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {boolean} [fullText] Whether to perform a full-text search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByName(name: string, fields?: Array<string>, fullText?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByName(name, fields, fullText, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search by region name
         * @param {string} region The region name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByRegion(region: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByRegion(region, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByRegion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search by subregion name
         * @param {string} subregion The subregion name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryBySubregion(subregion: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryBySubregion(subregion, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryBySubregion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search by translation name
         * @param {string} translation The translation name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByTranslation(translation: string, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByTranslation(translation, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByTranslation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get independent countries
         * @param {boolean} status Status of the countries to filter by
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndependentCountries(status: boolean, fields?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllresponsebodyInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndependentCountries(status, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getIndependentCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountriesApiFp(configuration)
    return {
        /**
         * Returns a simple example response.
         * @summary GET endpoint for retrieving all countries
         * @param {Array<string>} fields Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(fields: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getAllCountries(fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search by capital city name
         * @param {string} capital The capital city name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByCapital(capital: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getCountryByCapital(capital, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search by country code. It can be the 2-letter or 3-letter code
         * @param {string} code The country code to search ,for example for moldova 2-letter code i.e cca2  &#x3D; MD, 3-letter code i.e cca3 and cioc&#x3D; MDA, numeric code  i.e ccn3&#x3D;498
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByCode(code: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getCountryByCode(code, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search by currency code
         * @param {string} currency The currency code to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByCurrency(currency: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getCountryByCurrency(currency, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search by language code
         * @param {string} language The language code to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByLanguage(language: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getCountryByLanguage(language, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search by country name. If you want to get an exact match, use the next endpoint. It can be the common or official value
         * @param {string} name The name of the country to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {boolean} [fullText] Whether to perform a full-text search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByName(name: string, fields?: Array<string>, fullText?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getCountryByName(name, fields, fullText, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search by region name
         * @param {string} region The region name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByRegion(region: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getCountryByRegion(region, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search by subregion name
         * @param {string} subregion The subregion name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryBySubregion(subregion: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getCountryBySubregion(subregion, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search by translation name
         * @param {string} translation The translation name to search for
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByTranslation(translation: string, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getCountryByTranslation(translation, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get independent countries
         * @param {boolean} status Status of the countries to filter by
         * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndependentCountries(status: boolean, fields?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AllresponsebodyInner>> {
            return localVarFp.getIndependentCountries(status, fields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * Returns a simple example response.
     * @summary GET endpoint for retrieving all countries
     * @param {Array<string>} fields Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getAllCountries(fields: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getAllCountries(fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search by capital city name
     * @param {string} capital The capital city name to search for
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByCapital(capital: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByCapital(capital, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search by country code. It can be the 2-letter or 3-letter code
     * @param {string} code The country code to search ,for example for moldova 2-letter code i.e cca2  &#x3D; MD, 3-letter code i.e cca3 and cioc&#x3D; MDA, numeric code  i.e ccn3&#x3D;498
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByCode(code: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByCode(code, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search by currency code
     * @param {string} currency The currency code to search for
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByCurrency(currency: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByCurrency(currency, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search by language code
     * @param {string} language The language code to search for
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByLanguage(language: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByLanguage(language, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search by country name. If you want to get an exact match, use the next endpoint. It can be the common or official value
     * @param {string} name The name of the country to search for
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {boolean} [fullText] Whether to perform a full-text search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByName(name: string, fields?: Array<string>, fullText?: boolean, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByName(name, fields, fullText, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search by region name
     * @param {string} region The region name to search for
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByRegion(region: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByRegion(region, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search by subregion name
     * @param {string} subregion The subregion name to search for
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryBySubregion(subregion: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryBySubregion(subregion, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search by translation name
     * @param {string} translation The translation name to search for
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByTranslation(translation: string, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByTranslation(translation, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get independent countries
     * @param {boolean} status Status of the countries to filter by
     * @param {Array<string>} [fields] Comma-separated list of fields to include in the response for filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getIndependentCountries(status: boolean, fields?: Array<string>, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getIndependentCountries(status, fields, options).then((request) => request(this.axios, this.basePath));
    }
}



